# TAP-complex-data
JS module helping users to query and browse complex data exposed in a IVOA TAP service
Retrieving Complex Data in TAP services

Thanks to the Virtual Observatory, users can query services through a common language (ADQL) to get data directly from databases and they can choose an output format derived from a simple table serialization: votable, TSV and so on.

To write advanced queries, users must first understand the database schema to identify the tables containing data of interest and to figure out how to join them. Some tools (TOPCAT, TAPHandle, Aladin) propose generic interfaces helping for this but none of these tools is capable of providing a convenient view of a table set containing complex data.
It is furthermore difficult to reconstruct complex data structures from flattened tables usually returned by SQL queries.
TAP Simbad is a significant example of this difficulty with data spread out over 25 tables linked by foreign keys.

We are working on a client module addressing this issue  for TAP Web interfaces . The database schema, namely the TAP_SCHEMA, is analysed to build a JSON representation of complex data that can be annotated with query constraints set by the user. So that complex queries can be easily setup and run. Query results are parsed out  to reconstruct the data structure in JSON strings, where  top level data are explicitly listed and subcomponents can be fetched with appropriate synchronous TAP queries. These queries are generated by the parser and included within  the JSON output. Thus, users can unfold on demand any part of the searched data.

This mechanism  is being implemented in Javascript to be proposed as a new overlay for both Simbad and TAPHandle interfaces.




In the JAVASCRIPT folder, there are two main folders, one is the client folder: contains the js / html / css files needed by the page. In the simbad folder in the client folder is a js / html / css file that is specially given to the simbad database. If you need to run the page, you can run client / html / TestTs.html or client / simbad / html / simbad.html.
The other is the module folder: it contains four main typescript files in the ts folder. The corresponding js file is automatically generated under the monitoring ts / tsconfig.json file.

# main.js/ simbadMain.js：(example)
```
function simbadMain(){
    initial();
    $("#bObject").click(function(){// The name of the button can be changed in initial
        var s = new TapService("http://simbad.u-strasbg.fr/simbad/sim-tap/sync","public","Simbad",true);
        var data = s.createJson();
        var sj=new jsonRead(data); 
        $("#load1").empty();
        var output = sj.json2Html("basic");
        $("#load1").html(output);
        Aide(sj,s)
        limitJson2data(sj,s);
    })
}
```

To run the program. First you need to add an initial () function. This function initializes the page. The components inside can be modified.  
Then you need to instantiate TapService.  
If there is a TOP100 checkbox. You can set the value of the check box to false first. If the check box is checked, you can set the value to true again. Pass the value of the check box to TapService.（The fourth parameter.）  
var s = TapService("http://simbad.u-strasbg.fr/simbad/sim-tap/sync","public","Simbad",true);  
After instantiation, the first json file can be generated.  
var json1 = s.createJson（）  
Based on this basic json file we can instantiate jsonRead.  
var sj = jsonRead（json1）  
sj.json2Html (roottable) generates an html document based on the root table. It contains Aide buttons and restricted input boxes. Then add Aide (sj, s) and limitJson2data (sj, s) to add functionality in the html document.（ contains all the functions after the input limit.）  

# limitJson2data（sj，s）：
**joinAndId (root, json)** returns the id value and table name of all jointables in the root table.  
The latter part of the function is divided into three main parts. There will be a variable that records whether there are input restrictions. 1. If the variable is -1, there is no limit. An adql statement will be generated to query the data of the root table. 2. If the variable is not -1, it means that the user has entered a limit, and an adql statement containing a limit condition will be generated. 3. The program in the third part of the page after the Query ADQL button is clicked.  
The first two parts are basically similar. Will generate two json files. The first json file is an adql statement that stores the root table and other tables according to the key value. The second json file is to generate a json file with restrictions and table information for the adql statement. The generated adql statement then displays the information on the page through a query function.  
The third part of the logic is basically similar to the previous two parts. However, according to the adql statement manually modified by the user, the key value of the table is searched again, and a query data page is generated.  


# jsonRead.ts
Need to be instantiated.  
Pass in the first json file. Most functions in the file will use this json file.  
**mostUsed ()** sorts based on the number of jointables. Select the top five tables. It will read the json file in the instantiation.  
**showAll ()** is a recursive function. He simply converts table relationships into html documents. To display on the page.  
**json2Html (rootTable)** enters the root table into the function, and generates an html document based on the root table that contains all table relationships. Matching the value is the createNewJson function in Tapservice, which will generate a json file based on the root table.  
**CreateJsonAndContraint ()** column will output the key values of the root table and other tables by default. If the root table is basic, the key values of basic and other tables will be output: oid, otype.  
**CreateJsonWithoutColumns ()** column will output all the values of the root table by default. If the root table is basic, basic. * Is output.  


# json2Requete.ts
Read a json file containing restrictions and generate adql statements.  
**getAdql ()** is the main function.  



# TapService.ts
Need to be instantiated. Pass the url, schema, label, and checkstatues of the query platform (whether TOP100 is selected or not by default).  
**Query ()** can query any adql. But after the query, you need to use the votable2Rows function in VOTableTool.ts to get the formatted data.  
**createJson ()** generates the first json file. All tables and its first level jointables.  
**createNewJson ()** generates a json file based on the root table. It contains all the table join relationships.  
**createMainJson ()** generates a json file based on each id connected to the root table. It will generate an adql statement that searches all table data in the next layer based on the id.  
*removeViewTable ()* removes a table whose type is a view.  


# VOTableTools.ts
This is a static class and does not need to be instantiated. It can be called directly.  
The object received after the ajax query is directly passed to votable2Rows () to obtain the formatted data. The data is stored in an array.  
**genererFiled ()** gets the name of the Filed  


